mutate(LoggerDate = paste0(Logger, Date))
dat.wbnu <- all_visits %>%
ungroup() %>%
filter(Species == "WBNU") %>%
mutate(LoggerDate = paste0(Logger, Date))
dat.dowo
dowoflocks_rep2=gmmevents(dat.dowo$Timestamp, dat.dowo$RFID, dat.dowo$Logger)
?gmmevents
dat.dowo$Timestamp
dat.dowo$LoggerDate
dowoflocks_rep2=gmmevents(dat.dowo$Timestamp, dat.dowo$RFID, dat.dowo$LoggerDate)
dowoflocks_rep2
dowoflocks_rep2$gbi
gbi4=dowoflocks_rep2$gbi
dim(gbi4)
dim(gbi1)
dowo_net=graph_from_adjacency_matrix(get_network(gbi4), mode="undirected", weighted=T)
indivs=read.csv("RFID_Records_fixed.csv")
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
sexassort_dowo=assortment.discrete(as_adj(dowo_net, sparse=F, attr="weight"), V(dowo_net)$sex, SE=T)
sexassort_dowo$r
V(dowo_net)$name
indivs$RFID
match(V(dowo_net)$name, indivs$RFID)
indivs
indivs=as.character(indivs)
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
indivs=read.csv("RFID_Records_fixed.csv")
indivs$RFID=as.character(indivs$RFID)
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
match(V(dowo_net)$name, indivs$RFID)
indivs$RFID
V(dowo_net)$name
#networks
library(asnipe)
library(igraph)
library(assortnet)
dowo_gmm=readRDS("conspecificDOWOflocks.rds")
str(dowo_gmm)
dowo_gbi=dowo_gmm$gbi
wbnu_gmm=readRDS("conspecificWBNUflocks.rds")
wbnu_gbi=wbnu_gmm$gbi
dowo_net=graph_from_adjacency_matrix(get_network(dowo_gbi), mode="undirected", weighted=T)
wbnu_net=graph_from_adjacency_matrix(get_network(wbnu_gbi), mode="undirected", weighted=T)
indivs=read.csv("RFID_Records_fixed.csv")
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
V(wbnu_net)$sex=indivs[match(V(wbnu_net)$name, indivs$RFID),"Sex"]
V(dowo_net)$age=indivs[match(V(dowo_net)$name, indivs$RFID),"Age"]
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
V(dowo_net)$name
indivs=read.csv("RFID_Records_fixed.csv")
indivs
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
V(dowo_net)$sex
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
dowo_net=graph_from_adjacency_matrix(get_network(gbi4), mode="undirected", weighted=T)
indivs=read.csv("RFID_Records_fixed.csv")
indivs$RFID=as.character(indivs$RFID)
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
sexassort_dowo=assortment.discrete(as_adj(dowo_net, sparse=F, attr="weight"), V(dowo_net)$sex, SE=T)
sexassort_dowo$r
#### Analysis code, Part 1 for Madsen, Vander Meiden & Shizuka: Social partners and temperature jointly affect morning foraging activity of small birds in winter#####
#generates network plots for Figure 1
#measures assortment and social differentiation
library(asnipe)
library(igraph)
library(assortnet)
dowo_gmm=readRDS("conspecificDOWOflocks.rds")
str(dowo_gmm)
dowo_gbi=dowo_gmm$gbi
wbnu_gmm=readRDS("conspecificWBNUflocks.rds")
wbnu_gbi=wbnu_gmm$gbi
dowo_net=graph_from_adjacency_matrix(get_network(dowo_gbi), mode="undirected", weighted=T)
wbnu_net=graph_from_adjacency_matrix(get_network(wbnu_gbi), mode="undirected", weighted=T)
indivs=read.csv("RFID_Records_fixed.csv")
head(indivs)
V(dowo_net)$sex=indivs[match(V(dowo_net)$name, indivs$RFID),"Sex"]
V(wbnu_net)$sex=indivs[match(V(wbnu_net)$name, indivs$RFID),"Sex"]
V(dowo_net)$age=indivs[match(V(dowo_net)$name, indivs$RFID),"Age"]
sex_color=data.frame(sex=c("F", "M", "U"), color=c("yellow", "purple", "white"))
plot(dowo_net, vertex.color=sex_color[match(V(dowo_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(dowo_net)$weight*30)
plot(wbnu_net, vertex.color=sex_color[match(V(wbnu_net)$sex, sex_color$sex), "color"], vertex.label="", edge.width=E(wbnu_net)$weight*30)
sexassort_dowo=assortment.discrete(as_adj(dowo_net, sparse=F, attr="weight"), V(dowo_net)$sex, SE=T)
sexassort_dowo$r
#do node permutations
random_sex_dowo=lapply(1:1000, function(x) sample(V(dowo_net)$sex, length(V(dowo_net)$sex), replace=F))
assort_rand_dowo=sapply(random_sex_dowo, function(x) assortment.discrete(as_adj(dowo_net, sparse=F, attr="weight"), x, SE=F)$r)
p_assort_dowo=length(which(assort_rand_dowo<sexassort_dowo$r))/1001
ci_assort_rand_dowo=quantile(assort_rand_dowo, probs = c(0.025, 0.925))
p_assort_dowo
ci_assort_rand_dowo
sexassort_wbnu=assortment.discrete(as_adj(wbnu_net, attr="weight", sparse=F), V(wbnu_net)$sex, SE=T)
sexassort_wbnu$r
#do node permutations and generate p-value and confidence interval for WBNU
random_sex_wbnu=lapply(1:1000, function(x) sample(V(wbnu_net)$sex, length(V(wbnu_net)$sex), replace=F))
assort_rand_wbnu=sapply(random_sex_wbnu, function(x) assortment.discrete(as_adj(wbnu_net, attr="weight", sparse=F), x, SE=F)$r)
p_assort_wbnu=length(which(assort_rand_wbnu<sexassort_wbnu$r))/1001
ci_assort_rand_wbnu=quantile(assort_rand_wbnu, probs = c(0.025, 0.925))
mean(assort_rand_wbnu)
p_assort_wbnu
ci_assort_rand_wbnu
hist(assort_rand_wbnu)
##assortment from group permutations.
load("dowo_results_20190814.rdat")
load("wbnu_results_20190814.rdat")
length(dowoperm.adjs)
assort_rand_dowo2=sapply(dowoperm.adjs, function(x) assortment.discrete(x, V(dowo_net)$sex)$r)
p_assort_dowo2=length(which(assort_rand_dowo2<sexassort_dowo$r))/1001
p_assort_dowo2
quantile(assort_rand_dowo2, probs=c(0.025, 0.975))
sexassort_dowo$r
assort_rand_wbnu2=sapply(wbnuperm.adjs, function(x) assortment.discrete(x, V(wbnu_net)$sex)$r)
p_assort_wbnu2=length(which(assort_rand_wbnu2<sexassort_wbnu$r))/1001
p_assort_wbnu2
quantile(assort_rand_wbnu2, probs=c(0.025, 0.975))
sexassort_wbnu$r
cv=function(x) sd(x)/mean(x)
cv_dowo_emp=cv(E(dowo_net)$weight)
cv_dowo_rand=sapply(dowoperm.adjs, function(y) cv(y))
hist(cv_dowo_rand, xlim=c(0.65, 1.3))
lines(c(cv_dowo_emp, cv_dowo_emp), c(0,200), lty=2, col="red", lwd=2)
quantile(cv_dowo_rand, probs=c(0.025, 0.975))
cv_wbnu_emp=cv(E(wbnu_net)$weight)
cv_wbnu_rand=sapply(wbnuperm.adjs, function(y) cv(y))
hist(cv_wbnu_rand, xlim=c(0.8, 2.2))
lines(c(cv_wbnu_emp, cv_wbnu_emp), c(0,200), lty=2, col="red", lwd=2)
quantile(cv_wbnu_rand, probs=c(0.025, 0.975))
ci_assort_rand_wbnu
#do node permutations and generate p-value and confidence interval for WBNU
random_sex_wbnu=lapply(1:1000, function(x) sample(V(wbnu_net)$sex, length(V(wbnu_net)$sex), replace=F))
assort_rand_wbnu=sapply(random_sex_wbnu, function(x) assortment.discrete(as_adj(wbnu_net, attr="weight", sparse=F), x, SE=F)$r)
p_assort_wbnu=length(which(assort_rand_wbnu<sexassort_wbnu$r))/1001
ci_assort_rand_wbnu=quantile(assort_rand_wbnu, probs = c(0.025, 0.925))
mean(assort_rand_wbnu)
p_assort_wbnu
ci_assort_rand_wbnu
p_assort_wbnu2
cv=function(x) sd(x)/mean(x)
cv_dowo_emp=cv(E(dowo_net)$weight)
cv_dowo_rand=sapply(dowoperm.adjs, function(y) cv(y))
hist(cv_dowo_rand, xlim=c(0.65, 1.3))
lines(c(cv_dowo_emp, cv_dowo_emp), c(0,200), lty=2, col="red", lwd=2)
quantile(cv_dowo_rand, probs=c(0.025, 0.975))
load('all_visits.dat')
## daily visits per individual
dv <- all_visits %>%
filter(Date < "2019-03-11" & Date > "2019-01-25") %>%
group_by(RFID, Date) %>%
summarise(dailyvisits = n())
## mean daily visits per individual
ref <- dv %>%
group_by(RFID) %>%
summarise(mdv = mean(dailyvisits)) %>%
ungroup()
## sd of daily visits
dvsd <- sd(dv$dailyvisits)
## build the df
require(reshape)
mat_ddm <- cast(dv, Date ~ RFID, value = "dailyvisits")
mat_ddm[is.na(mat_ddm)] <- 0
mat <- mat_ddm[2:46]/dvsd
myvec <- (ref$mdv[match(names(mat_ddm[2:45]), ref$RFID)])/dvsd
mat_final <- mat[1] - myvec[1]
for(i in 2:44){
mat_temp <- mat[i] - myvec[i]
mat_final <- cbind(mat_final, mat_temp)
}
### Similarity Matrix
## how similar are individuals' daily visitation z-scores?
require(proxy)
simmat <- as.matrix(simil(mat_final, by_rows = FALSE))
simmat
vis <- all_visits %>%
group_by(Logger, RFID) %>%
summarise(logvis = n()) %>%
ungroup()
### reshape data frame and calculate proportion of visits at each feeder
logsums <- cast(vis, Logger ~ RFID, value = "logvis")
logsums[is.na(logsums)] <- 0
y = colSums(logsums)
fin <- as.data.frame(mapply("/", logsums[-1], y))
### make correlation/similarity matrix
require(proxy)
logmat <- as.matrix(simil(fin, by_rows = FALSE))
logmat
#import files
gmmDOWO=readRDS("conspecificDOWOflocks.rds") #import gmm results file. Will need this for permuting group-by-individual matrices.
gmmWBNU=readRDS("conspecificWBNUflocks.rds") #import gmm results file. Will need this for permuting group-by-individual matrices.
gbi_dowo=gmmDOWO$gbi
gbi_wbnu=gmmWBNU$gbi
dowoadj=get_network(gbi_dowo)
wbnuadj=get_network(gbi_wbnu)
diag(dowoadj)=NA #make diagonal of adjacency matrices NA so we don't count these when normalizing values later.
diag(wbnuadj)=NA #make diagonal of adjacency matrices NA so we don't count these when normalizing values later.
## daily visits per individual
dv <- all_visits %>%
filter(Date < "2019-03-11" & Date > "2019-01-25") %>%
group_by(RFID, Date) %>%
summarise(dailyvisits = n())
## mean daily visits per individual
ref <- dv %>%
group_by(RFID) %>%
summarise(mdv = mean(dailyvisits)) %>%
ungroup()
## sd of daily visits
dvsd <- sd(dv$dailyvisits)
## build the df
mat_ddm <- cast(dv, Date ~ RFID, value = "dailyvisits")
mat_ddm[is.na(mat_ddm)] <- 0
mat <- mat_ddm[2:46]/dvsd
myvec <- (ref$mdv[match(names(mat_ddm[2:45]), ref$RFID)])/dvsd
mat_final <- mat[1] - myvec[1]
for(i in 2:44){
mat_temp <- mat[i] - myvec[i]
mat_final <- cbind(mat_final, mat_temp)
}
#mat_final <- cbind(mat_ddm$Date, mat_final)
### Similarity Matrix
## how similar are individuals' daily visitation z-scores?
require(proxy)
simmat <- as.matrix(simil(mat_final, by_rows = FALSE))
#########Spatial Overlap Matrix
### summarise number of visits at each feeder for each bird
vis <- all_visits %>%
group_by(Logger, RFID) %>%
summarise(logvis = n()) %>%
ungroup()
### reshape data frame and calculate proportion of visits at each feeder
logsums <- cast(vis, Logger ~ RFID, value = "logvis")
logsums[is.na(logsums)] <- 0
y = colSums(logsums)
fin <- as.data.frame(mapply("/", logsums[-1], y))
### make correlation/similarity matrix
require(proxy)
logmat <- as.matrix(simil(fin, by_rows = FALSE))
dowosim=simmat[match(rownames(dowoadj), rownames(simmat)), match(rownames(dowoadj), rownames(simmat))] #sort the activity correlation matrix so rows/columns match adjacency matrix
dowospat=logmat[match(rownames(dowoadj), rownames(logmat)), match(rownames(dowoadj), rownames(logmat))] #sort spatial correlation matrix so rows/columns match adjacency matrix.
#same for WBNU
wbnusim=simmat[match(rownames(wbnuadj), rownames(simmat)), match(rownames(wbnuadj), rownames(simmat))]
wbnuspat=logmat[match(rownames(wbnuadj), rownames(logmat)), match(rownames(wbnuadj), rownames(logmat))]
#MRQAP-without normalizing values.
mrqap.dsp(dowosim~dowoadj+dowospat) #using activity similarity as the response variable and network + logger similarity as a covariates. This is raw numbers, not normalized.
mrqap.dsp(wbnusim~wbnuadj+wbnuspat)
# #now, normalize all matrix values so that minimum number = 0 and maximum number = 1
normalize_matrix=function(m){
(m-min(m, na.rm=T))/(max(m, na.rm=T)-min(m, na.rm=T))
}
dowosim.norm=normalize_matrix(dowosim)
dowoadj.norm=normalize_matrix(dowoadj)
dowospat.norm=normalize_matrix(dowospat)
dowo.mrqap.norm=mrqap.dsp(dowosim.norm~dowoadj.norm+dowospat.norm) #same test, but now with normalized values. The results are the same but the coefficient is different.
dowo.mrqap.norm
str(dowo.mrqap.norm)
mean(dowo.mrqap.norm$fitted.values)
mean(dowo.mrqap.norm$fitted.values)
dowo.ids=rownames(dowoadj)
dowogbi=gbi_dowo[,which(colnames(gbi_dowo)%in%dowo.ids)] #get gbi with only DOWOs
dowogbi.filt=dowogbi[which(rowSums(dowogbi)>0),] #remove groups that no DOWOs belong to.
dowometadata.filt=gmmDOWO$metadata[which(rowSums(dowogbi)>0),] #remove the same groups in the group metadata
#using the filtered metadata, we can extract the feeder & date of the group. This will be useful when we constrain the permutation by day
dowo.locations=as.numeric(as.factor(substr(dowometadata.filt$Location, start=1, stop=8)))
dowo.days=as.numeric(as.factor(substr(dowometadata.filt$Location, start=10, stop=13)))
#Run 10,000 group membership permutations with swaps constrained by date (but not feeder)
# dowoperm=network_permutation(dowogbi.filt, data_format="GBI", permutation=10000, association_matrix = dowoadj, locations=dowo.locations, days=dowo.days, within_day=TRUE, within_location=FALSE)
#
# plot(apply(dowoperm, 1, max), type="l", ylab="maximum edge weight", xlab="# swaps", main="DOWO permutations")
#store the results of MRQAP with empirical network
emp.mod.dowo=mrqap.dsp(dowosim.norm~dowoadj.norm+dowospat.norm)
emp.coef.dowo=emp.mod.dowo$coefficients[2]
#now do 1000 sets of swaps and store results
normalize_matrix=function(m){
(m-min(m, na.rm=T))/(max(m, na.rm=T)-min(m, na.rm=T))
}
times=1000
dowoperm.adjs=list()
for(i in 1:times){
dowoperm_repeat=network_swap(dowogbi.filt, data_format="GBI", swaps=10000, association_matrix = dowoadj, locations=dowo.locations, days=dowo.days, within_day=TRUE, within_location=FALSE)
dowoperm.adjs[[i]]=dowoperm_repeat$Association_index
}
dowoperm.mrqap.coefs=vector(length=times)
for(j in 1:times){
adj=dowoperm.adjs[[j]]
diag(adj)=NA
adj.norm=normalize_matrix(adj)
dowoperm.mrqap.coefs[j]=mrqap.dsp(dowosim.norm~adj.norm+dowospat.norm, randomisations=1)$coefficients[2]
}
dowoperm.mrqap.coefs
p.dowo=(length(which(dowoperm.mrqap.coefs>=emp.coef.dowo))+1)/(times+1)
p.dowo #p-value
ci.dowo=quantile(dowoperm.mrqap.coefs, probs=c(0.025, 0.975))
ci.dowo #confidence interval of null model -- this likely will not overlap the empirical coefficient value
times
i
### WBNU with parallel processing!
library(foreach)
times=1000
n.cores=detectCores()
system.time({
registerDoParallel(n.cores)
wbnu.results.parallel=foreach(i = 1:times) %dopar% as.matrix(network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)$Association_index)
})
stopImplicitCluster()
library(help='foreach')
library(parallel)
times=1000
n.cores=detectCores()
system.time({
registerDoParallel(n.cores)
wbnu.results.parallel=foreach(i = 1:times) %dopar% as.matrix(network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)$Association_index)
})
library(doParallel)
library(doParallel)
library(help='doParallel')
library(parallel)
library(doParallel)
times=1000
n.cores=detectCores()
system.time({
registerDoParallel(n.cores)
wbnu.results.parallel=foreach(i = 1:times) %dopar% as.matrix(network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)$Association_index)
})
stopImplicitCluster()
###WBNU
wbnu.ids=rownames(wbnuadj)
wbnugbi=gbi_wbnu[,which(colnames(gbi_wbnu)%in%wbnu.ids)] #get gbi with only wbnus
wbnugbi.filt=wbnugbi[which(rowSums(wbnugbi)>0),] #remove groups that no wbnus belong to.
wbnumetadata.filt=gmmWBNU$metadata[which(rowSums(wbnugbi)>0),] #remove the same groups in the group metadata
#using the filtered metadata, we can extract the feeder & date of the group. This will be useful when we constrain the permutation by day
wbnu.locations=as.numeric(as.factor(substr(wbnumetadata.filt$Location, start=1, stop=8)))
wbnu.days=as.numeric(as.factor(substr(wbnumetadata.filt$Location, start=10, stop=13)))
#store the results of MRQAP with empirical network
wbnusim.norm=normalize_matrix(wbnusim)
wbnuadj.norm=normalize_matrix(wbnuadj)
wbnuspat.norm=normalize_matrix(wbnuspat)
emp.mod.wbnu=mrqap.dsp(wbnusim.norm~wbnuadj.norm+wbnuspat.norm)
emp.coef.wbnu=emp.mod.wbnu$coefficients[2]
#now do 1000 sets of swaps and store results
# times=1000
# wbnuperm.adjs=list()
# for(i in 1:times){
#   wbnuperm_repeat=network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)
#   wbnuperm.adjs[[i]]=wbnuperm_repeat$Association_index
# }
#
# wbnuperm.mrqap.coefs=vector(length=times)
# for(j in 1:times){
#   adj=wbnuperm.adjs[[j]]
#   diag(adj)=NA
#   adj.norm=normalize_matrix(adj)
#   wbnuperm.mrqap.coefs[j]=mrqap.dsp(wbnusim.norm~adj.norm+wbnuspat.norm, randomisations=1)$coefficients[2]
# }
#
# wbnuperm.mrqap.coefs
#
# p.wbnu=(length(which(wbnuperm.mrqap.coefs>=emp.coef.wbnu))+1)/(times+1)
# p.wbnu #p-value
#
# ci.wbnu=quantile(wbnuperm.mrqap.coefs, probs=c(0.025, 0.975))
# ci.wbnu #confidence interval of null model -- this likely will not overlap the empirical coefficient value
#
#
# save(wbnuperm.adjs, wbnuperm.mrqap.coefs, p.wbnu, ci.wbnu, file="dowo_results_20190814_rdat")
### WBNU with parallel processing!
library(foreach)
library(parallel)
library(doParallel)
times=1000
n.cores=detectCores()
system.time({
registerDoParallel(n.cores)
wbnu.results.parallel=foreach(i = 1:times) %dopar% as.matrix(network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)$Association_index)
})
stopImplicitCluster()
### WBNU with parallel processing!
library(foreach)
library(parallel)
library(doParallel)
times=10
n.cores=detectCores()
system.time({
registerDoParallel(n.cores)
wbnu.results.parallel=foreach(i = 1:times) %dopar% as.matrix(network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)$Association_index)
})
stopImplicitCluster()
system.time({
times=10
wbnuperm.adjs=list()
for(i in 1:times){
wbnuperm_repeat=network_swap(wbnugbi.filt, data_format="GBI", swaps=10000, association_matrix = wbnuadj, locations=wbnu.locations, days=wbnu.days, within_day=TRUE, within_location=FALSE)
wbnuperm.adjs[[i]]=wbnuperm_repeat$Association_index
}
wbnuperm.mrqap.coefs=vector(length=times)
for(j in 1:times){
adj=wbnuperm.adjs[[j]]
diag(adj)=NA
adj.norm=normalize_matrix(adj)
wbnuperm.mrqap.coefs[j]=mrqap.dsp(wbnusim.norm~adj.norm+wbnuspat.norm, randomisations=1)$coefficients[2]
}
})
#.libPaths("C:/Users/Laura/Desktop/RLibrary")
library(tidyverse)
library(stringr)
library(igraph)
library(asnipe)
library(lubridate)
library(assortnet)
#Feeder RFID data for all species unsorted
datnut = read.csv("CleanFeederData3_10.csv")
datnut$Lubridate = parse_date_time(datnut$Datetime, "%m%d%H%M%S") #make date time object
datnut$Timestamp=as.numeric(datnut$Lubridate) #get seconds passed from date time object, neet to do this from start time of project
datnut$Day=day(datnut$Lubridate) #pull day from datetime object
datnut$Month=month(datnut$Lubridate)
datnut = unite(datnut, "LoggerDate", c("Logger", "Month", "Day"), remove=F) #make logger day, month object
datnut=datnut[complete.cases(datnut),]
##filter out logger 04 date collect 02012019
# datno4 = datnut[!(datnut$Logger=="LOGGER04"& datnut$DateCollected =="2019-02-01"),]
#
# #Need to sort by species
# birddat = read.csv("RFID_Records_fixed.csv", colClasses = c("RFID" ="character"))
#
# dat = merge(datno4, birddat[, c("RFID", "Species")], by="RFID")
##filter out logger 04 date collect 02012019
#Need to sort by species
birddat = read.csv("RFID_Records_fixed.csv", colClasses = c("RFID" ="character"))
dat = merge(datnut, birddat[, c("RFID", "Species")], by="RFID")
datDOWO = filter(dat, Species == "DOWO")
datDOWO = distinct(datDOWO)
datWBNU = filter(dat, Species == "WBNU")
datWBNU = datWBNU[,which(colnames(datWBNU)!="X")]
datWBNU = distinct(datWBNU)
#testing issues
#WBNUtest = filter(datWBNU, LoggerDate == "LOGGER02_1_29")
test = gmmevents(WBNUtest$Timestamp, WBNUtest$RFID, WBNUtest$LoggerDate)
#WBNUtest2 = filter(datWBNU, LoggerDate == "LOGGER01_1_29")
test2 = gmmevents(WBNUtest2$Timestamp, WBNUtest2$RFID, WBNUtest2$LoggerDate)
#DOWOtest = filter(datDOWO, LoggerDate == "LOGGER02_1_29")
test.dowo = gmmevents(DOWOtest$Timestamp, DOWOtest$RFID, DOWOtest$LoggerDate)
#running events by species
DOWOflocks_replicate2 = gmmevents(datDOWO$Timestamp, datDOWO$RFID, datDOWO$LoggerDate)
gbi5=DOWOflocks_replicate2$gbi
dim(gbi1)
dim(gbi2)
dim(gbi3)
dim(gbi5)
datDOWO
length(unique(datDOWO$RFID))
dim(gbi4)
dim(gbi1)
dim(gbi2)
dim(gbi3)
#.libPaths("C:/Users/Laura/Desktop/RLibrary")
library(tidyverse)
library(stringr)
library(igraph)
library(asnipe)
library(lubridate)
library(assortnet)
#Feeder RFID data for all species unsorted
datnut = read.csv("CleanFeederData3_10.csv")
datnut$Lubridate = parse_date_time(datnut$Datetime, "%m%d%H%M%S") #make date time object
datnut$Timestamp=as.numeric(datnut$Lubridate) #get seconds passed from date time object, neet to do this from start time of project
datnut$Day=day(datnut$Lubridate) #pull day from datetime object
datnut$Month=month(datnut$Lubridate)
datnut = unite(datnut, "LoggerDate", c("Logger", "Month", "Day"), remove=F) #make logger day, month object
datnut=datnut[complete.cases(datnut),]
##filter out logger 04 date collect 02012019
# datno4 = datnut[!(datnut$Logger=="LOGGER04"& datnut$DateCollected =="2019-02-01"),]
#
# #Need to sort by species
# birddat = read.csv("RFID_Records_fixed.csv", colClasses = c("RFID" ="character"))
#
# dat = merge(datno4, birddat[, c("RFID", "Species")], by="RFID")
##filter out logger 04 date collect 02012019
#Need to sort by species
birddat = read.csv("RFID_Records_fixed.csv", colClasses = c("RFID" ="character"))
dat = merge(datnut, birddat[, c("RFID", "Species")], by="RFID")
datDOWO = filter(dat, Species == "DOWO")
datDOWO = distinct(datDOWO)
DOWOflocks_replicate4 = gmmevents(datDOWO$Timestamp, datDOWO$RFID, datDOWO$LoggerDate)
gbi5=DOWOflocks_replicate4$gbi
dim(gbi5)
DOWOflocks_replicate2$gbi
dim(DOWOflocks_replicate2$gbi)
dim(gbi5)
dim(gbi1)
dim(gbi2)
dim(gbi3)
dim(gbi5)
gbi5=DOWOflocks_replicate2$gbi
gbi6=DOWOflocks_replicate4$gbi
dim(gbi6)
gbi5=DOWOflocks_replicate2$gbi
gbi6=DOWOflocks_replicate4$gbi
dim(gbi3)
dim(gbi5)
dim(gbi6)
